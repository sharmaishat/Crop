# -*- coding: utf-8 -*-
"""crop.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10-8PCWIj6cf7Vq7jgyjudEkYSnc2BfgN
"""

import streamlit as st
from PIL import Image
import zipfile
import os
from io import BytesIO
import hashlib

def crop_to_square(image):
    """Crops the image to a square keeping the center of the image."""
    width, height = image.size
    min_dim = min(width, height)
    left = (width - min_dim) // 2
    top = (height - min_dim) // 2
    right = left + min_dim
    bottom = top + min_dim
    return image.crop((left, top, right, bottom))

def main():
    st.title("Square Image Cropper")
    st.write("Upload multiple images, and they will be cropped to a square format while keeping the center of interest.")

    uploaded_files = st.file_uploader("Choose images", type=["jpg", "jpeg", "png"], accept_multiple_files=True)

    if uploaded_files:
        cropped_images = []
        custom_names = {}

        # Get custom names for each uploaded file
        for index, uploaded_file in enumerate(uploaded_files):
            file_hash = hashlib.md5(uploaded_file.read()).hexdigest()  # Generate a hash for the file
            uploaded_file.seek(0)  # Reset file pointer after reading

            custom_name = st.text_input(
                f"Enter custom name for {uploaded_file.name} (without extension):",
                key=file_hash
            )
            custom_names[uploaded_file.name] = custom_name.strip() if custom_name else None

        for uploaded_file in uploaded_files:
            try:
                with st.spinner(f"Processing {uploaded_file.name}..."):
                    img = Image.open(uploaded_file).convert("RGB")  # Convert to RGB to avoid mode errors
                    cropped_img = crop_to_square(img)
                    custom_name = custom_names.get(uploaded_file.name, os.path.splitext(uploaded_file.name)[0])
                    cropped_images.append((f"{custom_name}.jpg", cropped_img))
            except Exception as e:
                st.error(f"Failed to process {uploaded_file.name}: {e}")

        if cropped_images:
            # Display original and cropped images
            for name, cropped_img in cropped_images:
                st.image(cropped_img, caption=f"Cropped: {name}", width=300)

            # Create a ZIP file for all cropped images
            zip_buffer = BytesIO()
            with zipfile.ZipFile(zip_buffer, "w") as zip_file:
                for name, cropped_img in cropped_images:
                    try:
                        img_buffer = BytesIO()
                        cropped_img.save(img_buffer, format="JPEG")
                        zip_file.writestr(name, img_buffer.getvalue())
                    except Exception as e:
                        st.error(f"Failed to save {name} in ZIP file: {e}")

            zip_buffer.seek(0)

            # Provide a download button for the ZIP file
            st.download_button(
                label="Download All Cropped Images",
                data=zip_buffer,
                file_name="cropped_images.zip",
                mime="application/zip"
            )
        else:
            st.warning("No valid images to process.")

if __name__ == "__main__":
    main()












